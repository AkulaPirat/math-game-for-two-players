<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Точки-клеточки</title>
	<style>
	#gameCanvas {
		position: absolute;
		width: 100%;
		height: 70%;
		left: 0%;
		top: 20%;
		margin: 0px;
		padding: 0px;
		border: none;
		touch-action: none;
	}
	
	.bottom, .top, #info {
		border: none;
		font-size: 75px;
		color: #FFFFFF;
		text-align: center;
		background-color: #000000;
		width: 50%;
		height: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	#count1 {
		border-left: 1px solid black;
		background-color: #E03030;
		width: 25%;
	}
	#count2 {
		background-color: #3030E0;
		width: 25%;
	}
	
	#back_home {
		background-color: green;
	}
	#new_game {
		background-color: green;
		border-left: 1px solid black;
	}
	
	#info {
		width: 100%;
		background-color: #FFFFFF;
		color: #000000;
	}
	#info:hover {
		background-color: #EEEEEE;
	}
    </style>
</head>
<body>
	<div style="padding: 0; margin: 0; position: absolute; left: 0; top: 0%; width: 100%; height: 10%; display: flex; align-items: center; justify-content: space-around;">
		<button class="top" id="back_home">На главную</text>
		<button class="top" id="new_game">Новая игра</text>
	</div>
	<div style="padding: 0; margin: 0; position: absolute; left: 0; top: 10%; width: 100%; height: 10%; display: flex; align-items: center; justify-content: space-around;">
		<button id="info">Точки-клеточки</text>
	</div>
	<div style="padding: 0; margin: 0; position: absolute; left: 0; top: 90%; width: 100%; height: 10%; display: flex; align-items: center; justify-content: space-around;">
		<text class="bottom" id="move">Ходит</text>
		<text class="bottom" id="count1">0</text>
		<text class="bottom" id="count2">0</text>
	</div>
	<canvas id="gameCanvas"></canvas>
	
	<script src="js/line.js"></script>
	<script src="js/square.js"></script>
	<script>
		const settings = {
			area_size: 6, // в точках
			line_width: 10,
			padding: 50,
			padding_square: 10,
			colors: {
				color_none: "#D0D0D0",
				color_first: "#E03030",
				color_second: "#3030E0",
			},
		}
	
		if (window.innerWidth > window.innerHeight) {
			document.body.innerHTML = "";
			document.body.style.backgroundColor = "#A01010";
			let f = () => {alert("Переверните телефон в вертикальное положение и обновите страницу!"); setTimeout(f, 5000);};
			setTimeout(f, 100);
		}
		
		document.getElementById("back_home").addEventListener("click", (e) => {
			if (is_end || confirm("Вы уверены, что хотите вернуться на главную?\nТекущая игра будет завершена.")) {
				is_end = true;
				window.location.href = '/';
			}
		});
		document.getElementById("new_game").addEventListener("click", (e) => {
			if (is_end || confirm("Вы уверены, что хотите начать новую игру?\nЭта игра будет завершена.")) restart();
		});
		document.getElementById("info").addEventListener("click", (e) => {
			alert("Это действие недоступно по техническим причинам!");
		});
		
		window.addEventListener('beforeunload', (event) => {
			if (!is_end) {
				// Стандартный текст будет проигнорирован большинством браузеров
				const message = 'Возможно, внесенные изменения не сохранятся.';
				event.returnValue = message; // Необходимо для Chrome
				return message; // Необходимо для некоторых других браузеров
			}
		});
		
		const move_el = document.getElementById("move");
		const count1 = document.getElementById("count1");
		const count2 = document.getElementById("count2");
		
		move_el.style.backgroundColor = settings.colors.color_first;
		count1.style.backgroundColor = settings.colors.color_first;
		count2.style.backgroundColor = settings.colors.color_second;
		
		const canvas = document.getElementById('gameCanvas');
		const rect = canvas.getBoundingClientRect();
		canvas.width = rect.width;
		canvas.height = rect.height;
        ctx = canvas.getContext('2d');
		ctx.lineWidth = settings.line_width;
		
		let move = 1;
		let is_end = false;
		
		let linesX, linesY;
		let squares;
		let line_length = parseInt((Math.min(canvas.width, canvas.height) - settings.padding * 2) / (settings.area_size - 1));
		
		canvas.addEventListener("click", (e) => {
			if (is_end) return;
			
			const rect = canvas.getBoundingClientRect();
			const x_click = e.clientX - rect.left;
			const y_click = e.clientY - rect.top;
			let d_min = null;
			let x_min = 0, y_min = 0;
			let l_min = "x";
			for (let i = 0; i < settings.area_size; i++) {
				for (let j = 0; j < settings.area_size; j++) {
					if (i != settings.area_size - 1 && !linesX[i][j].is_active()) {
						let [x, y] = linesX[i][j].get_coordinate();
						let distance = Math.sqrt(Math.pow(x_click - x, 2) + Math.pow(y_click - y, 2));
						if (d_min == null || distance < d_min) {
							d_min = distance;
							x_min = i;
							y_min = j;
							l_min = "x";
						}
					}
					if (j != settings.area_size - 1 && !linesY[i][j].is_active()) {
						let [x, y] = linesY[i][j].get_coordinate();
						let distance = Math.sqrt(Math.pow(x_click - x, 2) + Math.pow(y_click - y, 2));
						if (d_min == null || distance < d_min) {
							d_min = distance;
							x_min = i;
							y_min = j;
							l_min = "y";
						}
					}
				}
			}
			const is_captured = (x, y) => (linesX[x][y].is_active() && linesY[x][y].is_active() && linesX[x][y + 1].is_active() && linesY[x + 1][y].is_active());
			
			if (l_min == "x") {
				linesX[x_min][y_min].set_active(move);
				let flag_captured = false;
				if (y_min != 0 && !squares[x_min][y_min - 1].is_active() && is_captured(x_min, y_min - 1)) {
					squares[x_min][y_min - 1].set_active(move);
					flag_captured = true;
					if (move == 1) count1.textContent = parseInt(count1.textContent) + 1;
					else count2.textContent = parseInt(count2.textContent) + 1;
				}
				if (y_min != settings.area_size - 1 && !squares[x_min][y_min].is_active() && is_captured(x_min, y_min)) {
					squares[x_min][y_min].set_active(move);
					flag_captured = true;
					if (move == 1) count1.textContent = parseInt(count1.textContent) + 1;
					else count2.textContent = parseInt(count2.textContent) + 1;
				}
				if (flag_captured) change_move();
			} else {
				linesY[x_min][y_min].set_active(move);
				let flag_captured = false;
				if (x_min != 0 && !squares[x_min - 1][y_min].is_active() && is_captured(x_min - 1, y_min)) {
					squares[x_min - 1][y_min].set_active(move);
					flag_captured = true;
					if (move == 1) count1.textContent = parseInt(count1.textContent) + 1;
					else count2.textContent = parseInt(count2.textContent) + 1;
				}
				if (x_min != settings.area_size - 1 && !squares[x_min][y_min].is_active() && is_captured(x_min, y_min)) {
					squares[x_min][y_min].set_active(move);
					flag_captured = true;
					if (move == 1) count1.textContent = parseInt(count1.textContent) + 1;
					else count2.textContent = parseInt(count2.textContent) + 1;
				}
				if (flag_captured) change_move();
			}
			
			draw();
			change_move();
			
			if (parseInt(count1.textContent) + parseInt(count2.textContent) == Math.pow(settings.area_size - 1, 2)) {
				setTimeout(() => { alert("Игра окончена! Победа " + (parseInt(count1.textContent) > parseInt(count2.textContent) ? "первого" : "второго") + " игрока.") }, 100);
				is_end = true;
				return;
			}
		});
		
		restart();		
		function restart() {
			move = 2;
			change_move();
			is_end = false;
			count1.textContent = count2.textContent = "0";
			
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			squares = [];
			linesX = [];
			linesY = [];
			for (let i = 0; i < settings.area_size; i++) {
				if (i != settings.area_size - 1) squares.push([]);
				if (i != settings.area_size - 1) linesX.push([]);
				linesY.push([]);
				for (let j = 0; j < settings.area_size; j++) {
					if (i != settings.area_size - 1 && j != settings.area_size - 1) squares[i].push(new Square(i, j, line_length, settings.padding, settings.padding_square, "#FFFFFF", settings.colors.color_first, settings.colors.color_second, canvas.width, canvas.height));
					if (i != settings.area_size - 1) linesX[i].push(new Line(i, j, line_length, settings.padding, false, settings.colors.color_none, settings.colors.color_first, settings.colors.color_second, canvas.width, canvas.height));
					if (j != settings.area_size - 1) linesY[i].push(new Line(i, j, line_length, settings.padding, true, settings.colors.color_none, settings.colors.color_first, settings.colors.color_second, canvas.width, canvas.height));
				}
			}
			
			draw();
		}
		
		function draw() {
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			// квадраты
			for (let i = 0; i < settings.area_size - 1; i++) {
				for (let j = 0; j < settings.area_size - 1; j++) {
					squares[i][j].draw();
				}
			}
			
			// линии
			for (let i = 0; i < settings.area_size; i++) {
				for (let j = 0; j < settings.area_size; j++) {
					if (i != settings.area_size - 1) linesX[i][j].draw();
					if (j != settings.area_size - 1) linesY[i][j].draw();
				}
			}
			
			// точки
			let x = (canvas.width - Math.min(canvas.width, canvas.height)) / 2 + settings.padding;
			let y = (canvas.height - Math.min(canvas.width, canvas.height)) / 2 + settings.padding;
			for (let i = 0; i < settings.area_size; i++) {
				for (let j = 0; j < settings.area_size; j++) {
					ctx.beginPath();
					ctx.fillStyle = "#000000";
					ctx.arc(x + line_length * i, y + line_length * j, 10, 0, Math.PI * 2);
					ctx.fill();
					ctx.closePath();
				}
			}
		}
		
		function change_move() {
			if (move == 1) {
				move = 2;
				move_el.style.backgroundColor = settings.colors.color_second;
			} else {
				move = 1;
				move_el.style.backgroundColor = settings.colors.color_first;
			}
		}
	</script>
</body>
</html>
